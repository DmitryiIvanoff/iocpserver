#pragma once
#include <winsock2.h>
#include <memory>
#include <mutex>

constexpr auto MAX_BUFF_SIZE = 8192;

enum enIOOperation {
	AcceptClient,
	SendToClient,
	ReadFromClient,
	WriteToClient,
	ReadFromIOCP
};


struct CBuffer {

	CBuffer() = delete;

	CBuffer(SOCKET clientSocket);

	~CBuffer();

	//структура WSAOVERLAPPED для асинхронных операций с ссокетом
	WSAOVERLAPPED               overlapped;	
	//буфер
	char                        buffer[MAX_BUFF_SIZE];
	//указательна на буфер и его длина
	WSABUF                      wsabuf;
	//сколько байт считали с сокета
	int                         nTotalBytes;
	//сколько байт записали в сокет
	int                         nSentBytes;
	//код операции
	enIOOperation                IOOperation;
	/*Эта переменная характеризует последовательность пакетов: при асинхронной записи в очередь порта завершения из разных потоков win не гарантирует что сообщение будет отправлено
	 именно в тот сокет в который предназначалось, это может привести к тому что данные будут посланы другому клиенту или к перемешиванию данных, т.к.
	 клиенты будут считывать данные в том порядке в котором они записали данные в сокет - тут работает очередь, допустим в очередь стали несколько 
	 клиентов (записали данные в сокеты): 1,2,3,4,5. Для клиента 3 операция выполняется быстрее, тогда получится что в очередь порта завершения запишутся 
	 результаты в следующем порядке: 3,1,2,4,5. Клиенты будут считывать данные в порядке очереди, тогда получится что клиент 1 считает данные, предназначенные для клиента 3, 
	 клиент 2 - для 1 и т.д. Для предотвращения такого поведения мы должны создать очередь и следить чтобы асинхронная запись в порт завершения происходиля в порядке чтения
	 пакетов отклиентов из него.*/
	size_t sequenceNumber;
	
	SOCKET m_dClientSocket;
	
	SOCKET m_dMySQLSocket;
	//Мы должны следить за тем чтобы за раз выполнялась только одна операция асинхронной записи в порт завершения для определенного сокета чтобы данные не перемешались.
	std::mutex m_mClientSync;
	
	size_t m_dSessionId;
};
typedef std::shared_ptr<CBuffer> BufferPtr;

